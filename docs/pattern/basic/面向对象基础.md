# 面向对象基础

**什么是面向对象**

面向对象编程（Object Oriented Programming，简称 OOP）是一种软件开发方法，也是一种编程范式。它通过将相关的数据和函数（或方法）组织成一个个的信息“孤岛”，即对象，来解决问题。这些对象是类的实例，而类则定义了对象的结构和行为。

**什么是面向过程编程**

面向过程编程是一种编程范式或编程风格。它以过程（可以为理解方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

**面向对象编程相比面向过程编程有哪些优势**

- 对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
- 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。

## 面向对象特性

- 封装
- 继承
- 多态
- 安全模式类

### 封装（Encapsulation）

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

### 抽象（Abstraction）

抽象主要指的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

### 继承（Inheritance）

继承是指一个对象直接使用另一个对象的方法和属性（非私有的）

### 多态（Polymorphism）

多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

## 代码质量评价指标

常用标准：

- 可维护性
- 可读性
- 可扩展性
- 灵活性
- 简洁性
- 可复用性
- 可测试性

### 可维护性（maintainability）

可维护性是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的“好”“坏”“优雅”之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。

### 可读性（readability）

软件设计大师 Martin Fowler 曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”翻译成中文就是：“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。

code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。

### 可扩展性（extensibility）

可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。

代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。

### 灵活性（flexibility）

当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。

当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。

当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。

从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。

### 简洁性（simplicity）

有一条非常著名的设计原则，你一定听过，那就是 KISS 原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。

### 可复用性（reusability）

代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。在后面的很多章节中，我们都会经常提到“可复用性”这一代码评价标准。

比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。

实际上，代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的，所以，在后面的章节中，当我们讲到 DRY 设计原则的时候，我还会讲更多代码复用相关的知识，比如，“有哪些编程方法可以提高代码的复用性”等。

### 可测试性（testability）

代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。

要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。

比如，面向对象中的继承、多态能让我们写出可复用的代码；
编码规范能让我们写出可读性好的代码；
设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；
设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等。

## 设计原则

- SOLID 原则
  - SRP 单一职责原则
  - OCP 开闭原则
  - LSP 里氏替换原则
  - ISP 接口隔离原则
  - DIP 依赖倒置原则
- LKP 最少知识原则(Least Knowledge Principle) / 迪米特法则(Law Of Demeter)
- DRY 原则(Don’t Repeat Yourself)
- KISS 原则(Keep It Simple，Stupid)
- YAGNI 原则
- LOD 法则
- 合成复用原则

### SRP 单一职责原则

‌**单一职责原则（SRP：Single Responsibility Principle）‌**是面向对象设计五个基本原则（SOLID）之一，由 ‌ 罗伯特·C·马丁（Robert C. Martin）在《敏捷软件开发：原则、模式与实践》一书中提出。**该原则强调一个类应该只有一个发生变化的原因，即一个类或模块应该有且只有一个职责。**
‌

#### 单一职责原则的核心思想

**单一职责原则的核心思想是，一个类只做一件事情，并且将这件事情做好。**

如果一个类承担了太多的职责，那么当其中一个职责发生变化时，可能会影响到其他职责的实现，从而增加系统的复杂性和维护成本。

通过将类的职责分解为多个独立的类，可以降低类的复杂度，提高代码的可读性和可维护性。
‌

#### 单一职责原则的应用和实战案例

在实际应用中，单一职责原则通常与 ‌ 接口隔离原则一起使用，通过将大接口拆分为多个小接口，每个接口只包含一个职责，从而实现接口的隔离。

例如，在一个电商平台中，订单处理可以拆分为订单创建、支付、发货和完成等多个独立的类，每个类负责一个具体的功能，从而提高系统的可维护性和扩展性。
‌

#### 单一职责原则的优缺点

优点：可以提高代码的内聚性和降低系统的耦合度，使得系统更容易维护和扩展。

缺点：可能会增加类的数量，从而增加系统的总体复杂度。

因此，在实际应用中需要根据具体情况权衡利弊，合理应用单一职责原则。

**适用范围：** 单一职责原则适用的范围有接口、方法、类。

---

强调类的职责单一。

### OCP 开闭原则

‌**开闭原则（Open-Closed Principle, OCP）‌** 是面向对象设计中的一个基本原则，其核心思想是 ‌**软件实体应该对扩展开放，对修改封闭 ‌。** 这意味着一个软件实体（如类、模块或函数）应该在不修改现有代码的基础上，能够通过扩展来适应新的需求或变化。

#### 开闭原则的实现方式

‌**抽象类和接口 ‌：** 通过定义抽象类和接口来约定行为，然后通过继承和实现这些抽象类和接口来扩展功能。
‌
**策略模式 ‌：** 将算法的实现分离到不同的类中，通过组合方式来实现不同的行为。
‌
**装饰器模式 ‌：** 通过对对象进行包装，动态地添加新的行为或功能。

#### 开闭原则的好处

‌**增强系统的稳定性 ‌：** 通过避免对现有代码的修改，可以减少引入新错误的风险。
‌
**提高系统的灵活性 ‌：** 可以方便地添加新功能，而不影响已有功能。
‌
**促进代码的复用 ‌：** 通过扩展已有代码，可以避免重复开发相同功能。

**违反开闭原则的后果**
违反开闭原则会导致系统难以维护和扩展，当需求变化时，可能需要大量修改现有代码，这不仅增加了开发成本，还可能引入新的错误。此外，系统的灵活性会大大降低，难以适应未来的变化。

---

对扩展开放，对修改关闭。在不修改现有代码的基础上，能够通过扩展来适应新的需求或变化。

策略模式

---

### LSP 里氏替换原则

里氏替换原则（Liskov Substitution Principle，LSP）是面向对象设计的基本原则之一。它由 ‌ 芭芭拉·利斯科夫（Barbara Liskov）在 1987 年提出，**旨在确保子类型（子类）可以替换掉基类型（父类），而不会改变程序的正确性。**

#### 里氏替换原则的核心内容和作用

**里氏替换原则的核心内容是任何基类可以出现的地方，子类一定可以出现。** 这意味着在软件设计中，**如果基类对象可以被替换为子类对象而不影响程序的正确性，那么这个设计就是遵循里氏替换原则的。** 这一原则是继承复用的基石，它确保了代码的扩展性和维护性，降低了因修改需求而引入错误的风险。

#### 里氏替换原则的应用示例

例如，假设有一个鸟类抽象类 Bird，其中包含一个方法 getFlyTime(int distance)用于计算飞行时间。如果有一个具体的鸟类实现 Swallow（燕子），其飞行速度为 120 千米/小时，另一个具体的鸟类实现 BrownKiwi（几维鸟），由于翅膀退化无法飞行。如果使用里氏替换原则，当用 Swallow 对象调用 getFlyTime 方法时，可以正确计算飞行时间；但如果用 BrownKiwi 对象调用，则会因为无法飞行而导致计算错误。这个例子说明了如果不遵守里氏替换原则，可能会导致程序在运行时出现错误。

---

不要破坏继承体系

### ISP 接口隔离原则

接口隔离原则（Interface Segregation Principle, ISP）‌ 是面向对象设计的一个基本原则，由 ‌ 罗伯特·C.马丁（Robert C. Martin）在 2002 年提出。**该原则主张使用多个专门的接口，而不是使用单一的总接口。** 客户端不应该依赖于它不需要的接口，**一个类对另一个类的依赖应该建立在最小的接口上。**
‌

#### 接口隔离原则的核心思想 ‌

**接口隔离原则的核心思想是将大接口拆分成更小的、更具体的接口，以减少客户端的依赖。** 当一个接口过大时，应该将其分割成更小的接口，这样使用该接口的客户端只需要知道与之相关的方法即可。每个接口应该承担一种相对独立的角色，不执行不属于其职责的任务，而专注于其核心功能。
‌

#### 接口隔离原则的优点 ‌

接口隔离原则的优点在于提高了系统的可维护性和可扩展性。通过将大接口拆分成多个小接口，可以使每个接口的功能更加明确和单一，从而减少接口之间的耦合度。这样，当需要对某个接口进行修改时，只会影响到使用该接口的特定部分，而不会对整个系统造成大的影响。此外，这种设计方式还有助于降低系统的复杂性，使得代码更加清晰和易于理解。
‌

#### 接口隔离原则的应用场景 ‌

接口隔离原则的应用场景主要包括大型接口拆分、客户端定制化和预防胖接口。当一个接口过于庞大，包含了许多不相关的方法时，应当考虑将其拆分成更小的、更具体的接口。这样做可以提高接口的可维护性和可扩展性，使得每个接口只负责一部分功能，降低了代码的耦合度，使得每个模块更加独立和可重用。
‌

#### 接口隔离原则与其他原则的关系 ‌

接口隔离原则与其他面向对象设计原则相辅相成，常与单一职责原则、开放封闭原则、里氏替换原则和依赖倒置原则共同应用。这些原则共同促进代码的质量，确保软件设计能够适应变化，同时保持代码的清晰和结构化。

---

在设计接口的时候要精简单

### DIP 依赖倒置原则

‌‌ 依赖倒置原则（Dependence Inversion Principle, DIP）‌ 是编程开发中的一个重要原则，**其核心思想是要求程序要依赖于抽象接口，而不是直接依赖于具体实现。** 这一原则旨在降低客户与实现模块之间的耦合度，从而提高系统的稳定性和可维护性。‌

#### 依赖倒置原则的核心内容

‌ 高层模块不应该依赖底层模块 ‌，二者都应该依赖其抽象。
抽象不应该依赖细节，细节应该依赖抽象。
依赖倒置的中心思想是面向接口编程，即通过定义接口来规定模块间的交互方式，而不是直接调用具体的实现类。

#### 依赖倒置原则的优点

‌

- **减少类间的耦合性 ‌：** 通过依赖抽象接口，可以降低不同模块之间的直接依赖，使得系统更加灵活。
- **提高系统稳定性 ‌：** 基于抽象的架构设计可以减少因具体实现变化而导致的系统不稳定。
- **提高代码可读性和可维护性 ‌：** 清晰的接口定义使得代码更加易于理解和维护。
  ‌ 降低修改程序所造成的风险 ‌：通过依赖抽象，可以减少因具体实现修改而导致的连锁反应。

#### 依赖倒置原则的缺点

‌

- **增加设计复杂度 ‌：** 需要定义更多的抽象层，可能会增加设计的复杂度。
- **学习曲线 ‌：** 对于初学者来说，理解并应用这一原则可能需要一定的时间。
- **性能影响 ‌：** 在某些极端情况下，过多的抽象层次可能会对性能产生一定影响。

在实际应用中，依赖倒置原则特别适用于大型项目和需求频繁变化的系统开发中。通过遵循这一原则，可以显著提高系统的可扩展性和维护性，减少因需求变更带来的风险。然而，对于小型项目或快速迭代的项目，其优势可能不那么明显，需要权衡利弊后决定是否采用。

---

要面向接口编程

### LKP 最少知识原则 / 迪米特法则

‌‌ 迪米特法则（Law of Demeter）‌，又称为最少知识原则（Least Knowledge Principle），是由 ‌Ian Holland 在 1987 年提出的。**这个原则强调一个对象应当对其他对象保持尽可能少的了解** ，也就是说，一个对象应当只与它的直接朋友（直接关联的对象）进行交互，而不是与那些不直接交互的“陌生人”进行通信。**迪米特法则的目的是为了降低类之间的耦合度，提高系统的灵活性和可维护性。‌**

#### 迪米特法则的主要思想

思想包括：

- 只与对象的“直接朋友”（直接关联的对象）进行交互 ‌，避免通过链式调用访问对象的内部信息，因为这会导致紧耦合。
- 降低耦合度 ‌：通过减少对象之间的依赖关系，提升系统的灵活性和可维护性。
- 提高模块化 ‌：有助于将功能模块化，便于进行单元测试和重构。
- 增强代码的可读性 ‌：清晰的责任边界使得代码更易于理解。

#### 迪米特法则的应用示例

‌- 门面模式 ‌ 和 ‌ 调停者模式（中介者模式）‌，这些模式实际上就是迪米特法则的应用。

- 在类的设计上，优先考虑将一个类设置成不变类，尽量降低一个类的访问权限，谨慎使用 Serializable 等。

#### 遵循迪米特法则可能会带来的缺点

- 在系统中造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。
- 可能会降低系统的不同模块之间的通信效率。

---

要降低耦合度

### CRP 合成复用原则

‌‌ 合成复用原则（Composite Reuse Principle, CRP）‌，也被称为 ‌ 组合/聚合复用原则（Composition/Aggregate Reuse Principle, CARP），是面向对象设计中的一个重要原则。**该原则的核心思想是优先使用对象组合或聚合，而不是通过继承来实现代码复用。** 这一原则旨在提高代码的灵活性和可维护性，同时降低类之间的耦合度。

#### 合成复用原则的定义和重要性

合成复用原则强调，通过组合或聚合多个对象来实现新的功能，而不是通过继承来扩展类的功能。这种做法有助于维持类的封装性，减少类之间的紧密耦合，提高系统的灵活性和可维护性。相比之下，继承关系虽然简单易实现，但会破坏类的封装性，增加类之间的耦合度，限制了复用的灵活性。

#### 合成复用原则与继承的关系

合成复用原则与继承关系的关系可以概括为：在软件复用时，应优先使用组合或聚合等关联关系，只有在明确需要继承的情况下才使用继承。继承关系虽然能够将父类的功能直接传递给子类，但这种做法会暴露父类的实现细节，导致子类与父类的耦合度较高，不利于系统的扩展和维护。而组合或聚合关系则允许新对象通过调用已有对象的功能来实现复用，这种做法维持了类的封装性，降低了类之间的耦合度，提高了系统的灵活性和可维护性。

#### 合成复用原则的应用实例

为了更好地理解合成复用原则，可以参考一些实际应用场景。

例如，在构建一个汽车分类管理程序中，可以通过组合或聚合的方式将不同的汽车类型（如轿车、卡车、摩托车等）纳入到一个更大的管理系统中。这种方式不仅降低了类之间的耦合度，还提高了系统的灵活性和可维护性。相比之下，如果采用继承关系来实现同样的功能，随着汽车类型的增加和维护的复杂性增加，系统将变得难以管理和扩展。

综上所述，合成复用原则通过优先使用对象组合或聚合的方式来实现代码复用，旨在提高系统的灵活性、降低类之间的耦合度，从而增强系统的可维护性和扩展性。这一原则在面向对象设计中具有重要意义，特别是在需要高度灵活和可维护的系统设计中。

---

要优先使用组合或者聚合关系复用，少用继承关系复用。
