import{_ as e,c as r,o as t,ag as i}from"./chunks/framework.DPDPlp3K.js";const m=JSON.parse('{"title":"算法思想","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/basic/基本算法思想.md","filePath":"algorithm/basic/基本算法思想.md"}'),p={name:"algorithm/basic/基本算法思想.md"};function n(o,a,l,h,d,c){return t(),r("div",null,a[0]||(a[0]=[i('<h1 id="算法思想" tabindex="-1">算法思想 <a class="header-anchor" href="#算法思想" aria-label="Permalink to &quot;算法思想&quot;">​</a></h1><h2 id="分治算法" tabindex="-1">分治算法 <a class="header-anchor" href="#分治算法" aria-label="Permalink to &quot;分治算法&quot;">​</a></h2><p>分而治之，先解决子问题，再将子问题的解合并求出原问题。</p><p>依赖：递归法</p><p>过程：</p><ul><li>分解：将原问题分解成一系列子问题。</li><li>解决：递归求解各个子问题，若子问题足够小，则直接求解。</li><li>合并：将子问题的结果合并成原问题。</li></ul><p>应用：快速排序、归并排序</p><p>时间复杂度：O(nlogn) 空间复杂度：O(n)</p><h2 id="贪心算法" tabindex="-1">贪心算法 <a class="header-anchor" href="#贪心算法" aria-label="Permalink to &quot;贪心算法&quot;">​</a></h2><h2 id="枚举算法" tabindex="-1">枚举算法 <a class="header-anchor" href="#枚举算法" aria-label="Permalink to &quot;枚举算法&quot;">​</a></h2><h2 id="回溯算法" tabindex="-1">回溯算法 <a class="header-anchor" href="#回溯算法" aria-label="Permalink to &quot;回溯算法&quot;">​</a></h2><h2 id="动态规划-dynamic-programming" tabindex="-1">动态规划 Dynamic Programming <a class="header-anchor" href="#动态规划-dynamic-programming" aria-label="Permalink to &quot;动态规划 Dynamic Programming&quot;">​</a></h2><p>说明：动态规划是一种分阶段求解决策问题的数学思想。</p><p>应用：管理学、经济学、生物学、编程领域</p><p>核心：最优子结构、边界、状态转移公式</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h2 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h2><h3 id="场景1" tabindex="-1">场景1 <a class="header-anchor" href="#场景1" aria-label="Permalink to &quot;场景1&quot;">​</a></h3><p>题目：</p><p>有一个只能容纳10本书的单层书架，你每次只能放1本或2本书。要求用程序求出你将书架填满一共有多少种方法。</p><p>思路：</p><p>假设再放一次就可以将书架放满10本，情况有几种？（2种） 由于每次只能放1或2本。想要放满10本书，书架上一定放了8本或9本，而放满8本或9本的方法数量又已经知道，则放满10本书可以根据最后一步的不同而分成两部分。 1、已放9本，最后一次放1本。（放法数量和0到9本放法数量一样，即X） 2、已放8本，最后一次放2本。（放法数量和0到8本放法数量一样，即Y）</p><p>总的放法数量：X+Y</p><p>最优子结构：</p><p>F(9) + F(8) 是F(10)的最优子结构</p><p>边界：</p><p>F(1)、F(2)</p><p>状态转移公式：</p><p>F(n) = F(n-1)+F(n-2)（n&gt;=3）</p><p>F(1) = 1;</p><p>F(2) = 2;</p><p>F(10) = F(9) + F(8)</p><p>F(n) = F(n-1)+F(n-2)（n&gt;=3）</p><h3 id="场景2" tabindex="-1">场景2 <a class="header-anchor" href="#场景2" aria-label="Permalink to &quot;场景2&quot;">​</a></h3><p>一个楼梯共有50层台阶，你可以选择跨1层，跨2层，跨3层的方式通过楼梯，请问通过楼梯共有多少种方案？</p>',36)]))}const _=e(p,[["render",n]]);export{m as __pageData,_ as default};
