import{_ as a,c as t,o as r,ag as l}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"2.5 同构直出","description":"","frontmatter":{},"headers":[],"relativePath":"performanceGeek/2.5同构直出.md","filePath":"performanceGeek/2.5同构直出.md"}'),i={name:"performanceGeek/2.5同构直出.md"};function o(n,e,s,c,d,h){return r(),t("div",null,e[0]||(e[0]=[l('<h1 id="_2-5-同构直出" tabindex="-1">2.5 同构直出 <a class="header-anchor" href="#_2-5-同构直出" aria-label="Permalink to &quot;2.5 同构直出&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><ul><li>一套代码既可以在服务端运行又可以在客户端运行，这就是同构(Universal)。</li></ul><h2 id="技术优势" tabindex="-1">技术优势 <a class="header-anchor" href="#技术优势" aria-label="Permalink to &quot;技术优势&quot;">​</a></h2><ul><li>性能:降低首屏渲染时间</li><li>SEO:服务端渲染对搜索引擎的爬取有着天然的优势</li><li>兼容性:有效规避客户端兼容性问题，比如白屏</li><li>代码同构:直接上线线两个版本，利于灾备</li></ul><h2 id="技术实现" tabindex="-1">技术实现 <a class="header-anchor" href="#技术实现" aria-label="Permalink to &quot;技术实现&quot;">​</a></h2><ul><li>next.js:服务器端渲染React组件框架(参考查看:<code>&lt;https://nextjs.org/)，React采用&gt;</code> ReactDOMServer 调用renderToString() 方法。</li><li>gatsbyjs: 服务端React渲染框架(参考查看:<code>&lt;https://www.gatsbyjs.org/&gt;</code>)</li><li>nuxt.js: 服务器端渲染Vue组件框架(参考查看:<code>&lt;https://nuxtjs.org/)，Vue&gt;</code> 采用 vue-server-renderer 调用renderToString()方法</li></ul><h2 id="协作方式" tabindex="-1">协作方式 <a class="header-anchor" href="#协作方式" aria-label="Permalink to &quot;协作方式&quot;">​</a></h2><ul><li>后端专注于业务功能实现和API 接口封装。</li><li>前端负责实现页面前端交互，根据后端API接口拼装前端模板，页面渲染，以及服务器维护。 选型建议</li><li>前端要处理Node server的机器环境、代码部署、日志、容灾、监控等以往后端人员需要具备运维知识，前端人员的综合能力要求会比以往要高。</li><li>前端项目开发周期变长了，需要事先和产品、运营沟通排期问题。</li><li>总之一名话:“前端人力和能力够，直接上马，向全栈工程师迈进”。</li></ul>',9)]))}const m=a(i,[["render",o]]);export{u as __pageData,m as default};
