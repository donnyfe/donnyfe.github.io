import{_ as l,c as n,o as s,ag as i}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":"Nginx介绍","description":"","frontmatter":{},"headers":[],"relativePath":"nginx/Nginx.md","filePath":"nginx/Nginx.md"}'),e={name:"nginx/Nginx.md"};function o(r,a,t,p,c,g){return s(),n("div",null,a[0]||(a[0]=[i(`<h1 id="nginx介绍" tabindex="-1">Nginx介绍 <a class="header-anchor" href="#nginx介绍" aria-label="Permalink to &quot;Nginx介绍&quot;">​</a></h1><p>推荐阅读：<a href="http://tengine.taobao.org/nginx_docs/cn/" target="_blank" rel="noreferrer">中文文档阅读</a></p><p>nginx是一个HTTP和反向代理服务器，由俄罗斯<a href="http://sysoev.ru/en/" target="_blank" rel="noreferrer">Igor Sysoev</a>在2004年发10月布第一个版本0.1.0。</p><h2 id="nginx的特性" tabindex="-1">Nginx的特性 <a class="header-anchor" href="#nginx的特性" aria-label="Permalink to &quot;Nginx的特性&quot;">​</a></h2><ul><li>稳定性强，7*24小时不间断运行</li><li>Nginx提供了非常丰富的配置实例</li><li>占用内存小，并发能力强</li></ul><h2 id="nginx的优点" tabindex="-1">Nginx的优点 <a class="header-anchor" href="#nginx的优点" aria-label="Permalink to &quot;Nginx的优点&quot;">​</a></h2><h3 id="_1-高并发-高性能" tabindex="-1">1.高并发，高性能 <a class="header-anchor" href="#_1-高并发-高性能" aria-label="Permalink to &quot;1.高并发，高性能&quot;">​</a></h3><ul><li>采用多进程和I/O多路复用(epoll)的底层实现</li><li>在正常情况下单次请求响应更快</li><li>在高峰期(数以万计的并发请求)时仍能保持快速响应</li><li>相比其他Web服务器具有更快的响应速度</li></ul><h3 id="_2-可扩展性好" tabindex="-1">2. 可扩展性好 <a class="header-anchor" href="#_2-可扩展性好" aria-label="Permalink to &quot;2. 可扩展性好&quot;">​</a></h3><ul><li>模块化设计架构</li><li>支持官方和第三方模块的扩展</li><li>可以通过配置文件灵活添加模块</li><li>支持开发定制化模块来满足特定业务需求</li></ul><h3 id="_3-高可靠性" tabindex="-1">3. 高可靠性 <a class="header-anchor" href="#_3-高可靠性" aria-label="Permalink to &quot;3. 高可靠性&quot;">​</a></h3><ul><li>采用多进程模式运行:一个master主进程，多个worker工作进程</li><li>worker进程间相互独立</li><li>master进程可以在worker进程出错时快速启动新的worker进程</li><li>保证服务的持续性和稳定性</li></ul><h3 id="_4-热部署" tabindex="-1">4. 热部署 <a class="header-anchor" href="#_4-热部署" aria-label="Permalink to &quot;4. 热部署&quot;">​</a></h3><ul><li>支持724小时不间断运行</li><li>可以在不停止Nginx的情况下进行:文件升级、配置更新、日志文件更换</li><li>保证服务的持续性和稳定性,确保服务不中断的情况下完成维护工作</li></ul><h3 id="_5-bsd许可证" tabindex="-1">5. BSD许可证 <a class="header-anchor" href="#_5-bsd许可证" aria-label="Permalink to &quot;5. BSD许可证&quot;">​</a></h3><ul><li>开源</li><li>免费使用</li><li>可以免费用于商业用途</li></ul><h2 id="nginx的应用场景" tabindex="-1">Nginx的应用场景 <a class="header-anchor" href="#nginx的应用场景" aria-label="Permalink to &quot;Nginx的应用场景&quot;">​</a></h2><ul><li>静态文件服务器</li><li>反向代理服务器</li><li>负载均衡器</li><li>API网关</li><li>安全防护</li><li>静态化服务</li><li>图片实时处理</li><li>消息推送</li></ul><h2 id="nginx的架构" tabindex="-1">Nginx的架构 <a class="header-anchor" href="#nginx的架构" aria-label="Permalink to &quot;Nginx的架构&quot;">​</a></h2><ul><li><p>多进程（单线程）和多路IO复用模型</p></li><li><p>工作流程：</p><ul><li>IO多路复用</li><li>CPU亲和</li><li>sendfile：sendfile零拷贝模式</li></ul></li></ul><h2 id="nginx进程结构" tabindex="-1">Nginx进程结构 <a class="header-anchor" href="#nginx进程结构" aria-label="Permalink to &quot;Nginx进程结构&quot;">​</a></h2><p><strong>Master进程(主进程)</strong></p><ul><li>监控worker进程状态</li><li>管理worker进程的生命周期</li><li>接收并处理信号</li><li>向worker进程分发指令</li></ul><p><strong>Worker进程(工作进程)</strong></p><ul><li>处理实际的客户端请求</li><li>执行主进程分配的任务</li><li>处理网络事件</li></ul><p><strong>Cache相关进程</strong></p><ul><li>Cache Loader进程：负责载入缓存索引文件</li><li>Cache Manager进程：管理磁盘缓存大小</li></ul><h2 id="nginx进程管理" tabindex="-1">Nginx进程管理 <a class="header-anchor" href="#nginx进程管理" aria-label="Permalink to &quot;Nginx进程管理&quot;">​</a></h2><ul><li>重载配置：nginx -s reload 或 kill -HUP <code>master_pid</code></li><li>优雅关闭：nginx -s quit 或 kill -QUIT <code>master_pid</code></li><li>停止Nginx：nginx -s stop 或 kill -TERM <code>master_pid</code></li><li>重新打开日志文件：nginx -s reopen 或 kill -USR1 <code>master_pid</code></li></ul><h2 id="nginx的事件驱动模型" tabindex="-1">Nginx的事件驱动模型 <a class="header-anchor" href="#nginx的事件驱动模型" aria-label="Permalink to &quot;Nginx的事件驱动模型&quot;">​</a></h2><h3 id="_1-事件驱动架构" tabindex="-1">1. 事件驱动架构 <a class="header-anchor" href="#_1-事件驱动架构" aria-label="Permalink to &quot;1. 事件驱动架构&quot;">​</a></h3><ul><li>异步非阻塞：Nginx使用异步非阻塞I/O操作，这意味着它可以在等待I/O操作完成时继续处理其他请求，而不需要为每个连接分配一个线程或进程。</li><li>事件循环：Nginx使用事件循环来监听和处理事件（如网络请求、文件I/O等），通过事件通知机制来触发相应的处理程序。</li></ul><h3 id="_2-事件模型" tabindex="-1">2. 事件模型 <a class="header-anchor" href="#_2-事件模型" aria-label="Permalink to &quot;2. 事件模型&quot;">​</a></h3><p>Nginx支持多种事件模型，具体选择取决于操作系统：</p><ul><li>epoll：适用于Linux，是Nginx在Linux上的默认事件模型，支持大规模并发连接。</li><li>kqueue：适用于FreeBSD、OpenBSD和macOS，提供高效的事件通知机制。</li><li>select/poll：适用于几乎所有操作系统，但性能不如epoll和kqueue。</li><li>/dev/poll：适用于Solaris。</li><li>eventport：适用于Solaris 10。</li></ul><h3 id="_3-事件处理流程" tabindex="-1">3. 事件处理流程 <a class="header-anchor" href="#_3-事件处理流程" aria-label="Permalink to &quot;3. 事件处理流程&quot;">​</a></h3><ol><li>事件监听：Nginx的主进程启动后，工作进程会监听指定的端口和地址，等待客户端连接。</li><li>事件触发：当有新的连接或I/O事件发生时，事件模型会通知Nginx。 事件分发：Nginx将事件分发给相应的工作进程进行处理。</li><li>事件处理：工作进程处理事件，包括读取请求、发送响应、关闭连接等。</li><li>事件循环：处理完当前事件后，工作进程返回事件循环，继续监听新的事件。</li></ol><h2 id="热部署" tabindex="-1">热部署 <a class="header-anchor" href="#热部署" aria-label="Permalink to &quot;热部署&quot;">​</a></h2><p>热部署(nginx -s reload)</p><p>热部署的原理:</p><p>Nginx通过发送HUP信号给主进程（master process）来实现热部署。具体步骤如下：</p><ol><li>发送HUP信号：使用命令nginx -s reload或kill -HUP <code>master_pid</code>发送HUP信号给Nginx的主进程。</li><li>检查配置文件：主进程接收到信号后，首先检查新的配置文件的语法是否正确。</li><li>应用新配置：如果语法正确，主进程会应用新的配置，打开新的日志文件和监听端口。</li><li>启动新进程：主进程启动新的工作进程（worker processes）。</li><li>关闭旧进程：主进程向旧的工作进程发送QUIT信号，要求它们优雅地关闭。</li><li>处理现有连接：旧的工作进程会继续处理现有的连接，直到所有请求处理完毕后再退出。</li><li>完成重载：当所有旧的工作进程完成其任务后，它们会自动退出，整个重载过程完成。</li></ol><h2 id="日志文件切割" tabindex="-1">日志文件切割 <a class="header-anchor" href="#日志文件切割" aria-label="Permalink to &quot;日志文件切割&quot;">​</a></h2><p>在Nginx中，日志文件的切割（也称为日志轮转）是为了防止日志文件过大而影响系统性能。Nginx本身不提供日志切割的功能，但可以通过外部工具和脚本来实现。</p><h3 id="使用logrotate" tabindex="-1">使用logrotate <a class="header-anchor" href="#使用logrotate" aria-label="Permalink to &quot;使用logrotate&quot;">​</a></h3><p><code>logrotate</code>是一个常用的日志管理工具，可以自动切割、压缩和删除旧的日志文件。以下是配置<code>logrotate</code>来管理Nginx日志的步骤：</p><ol><li><p><strong>安装logrotate</strong>：大多数Linux发行版默认安装了<code>logrotate</code>，如果没有，可以通过包管理器安装。</p></li><li><p><strong>配置logrotate</strong>：</p><ul><li><p>创建或编辑<code>/etc/logrotate.d/nginx</code>文件，添加以下内容：</p><div class="language-plaintext"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span>/var/log/nginx/*.log {</span></span>
<span class="line"><span>    daily</span></span>
<span class="line"><span>    rotate 7</span></span>
<span class="line"><span>    compress</span></span>
<span class="line"><span>    delaycompress</span></span>
<span class="line"><span>    missingok</span></span>
<span class="line"><span>    notifempty</span></span>
<span class="line"><span>    create 640 nginx adm</span></span>
<span class="line"><span>    sharedscripts</span></span>
<span class="line"><span>    postrotate</span></span>
<span class="line"><span>        [ ! -f /var/run/nginx.pid ] || kill -USR1 \`cat /var/run/nginx.pid\`</span></span>
<span class="line"><span>    endscript</span></span>
<span class="line"><span>}</span></span></code></pre></div></li><li><p>该配置会每天切割日志，保留7天的日志，并压缩旧日志。</p></li></ul></li><li><p><strong>执行logrotate</strong>：<code>logrotate</code>通常由系统的cron任务自动执行，也可以手动运行<code>logrotate /etc/logrotate.conf</code>来测试配置。</p></li></ol><h3 id="手动脚本切割" tabindex="-1">手动脚本切割 <a class="header-anchor" href="#手动脚本切割" aria-label="Permalink to &quot;手动脚本切割&quot;">​</a></h3><p>可以编写一个简单的bash脚本来手动切割日志：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">#!/bin/bash</span></span>
<span class="line"><span style="color:#24292E;">DATE</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">$(</span><span style="color:#6F42C1;">date</span><span style="color:#032F62;"> +%Y-%m-%d-%H%M</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6F42C1;">mv</span><span style="color:#032F62;"> /var/log/nginx/access.log</span><span style="color:#032F62;"> /var/log/nginx/access.log.</span><span style="color:#24292E;">$DATE</span></span>
<span class="line"><span style="color:#6F42C1;">mv</span><span style="color:#032F62;"> /var/log/nginx/error.log.</span><span style="color:#24292E;">$DATE</span></span>
<span class="line"><span style="color:#005CC5;">kill</span><span style="color:#005CC5;"> -USR1</span><span style="color:#032F62;"> cat</span><span style="color:#032F62;"> /var/run/nginx.pid</span></span>
<span class="line"><span style="color:#6F42C1;">sleep</span><span style="color:#005CC5;"> 1</span></span>
<span class="line"><span style="color:#6F42C1;">gzip</span><span style="color:#032F62;"> /var/log/nginx/access.log.</span><span style="color:#24292E;">$DATE</span></span>
<span class="line"><span style="color:#6F42C1;">gzip</span><span style="color:#032F62;"> /var/log/nginx/error.log.</span><span style="color:#24292E;">$DATE</span></span></code></pre></div><ul><li>将该脚本保存为<code>nginx_log_rotate.sh</code>，并通过cron定期执行。</li></ul><h3 id="使用命名管道和外部工具" tabindex="-1">使用命名管道和外部工具 <a class="header-anchor" href="#使用命名管道和外部工具" aria-label="Permalink to &quot;使用命名管道和外部工具&quot;">​</a></h3><p>可以使用命名管道和工具如<code>cronolog</code>或<code>rotatelogs</code>来实现日志切割：</p><ol><li><p><strong>创建命名管道</strong>：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6F42C1;">mkfifo</span><span style="color:#032F62;"> /var/log/nginx/access.log.pipe</span></span></code></pre></div></li><li><p><strong>配置Nginx使用管道</strong>：</p><div class="language-nginx"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">access_log </span><span style="color:#24292E;">/var/log/nginx/access.log.pipe;</span></span></code></pre></div></li><li><p><strong>使用工具切割日志</strong>：</p><ul><li><p>使用<code>cronolog</code>：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6F42C1;">cat</span><span style="color:#032F62;"> /var/log/nginx/access.log.pipe</span><span style="color:#D73A49;"> |</span><span style="color:#6F42C1;"> cronolog</span><span style="color:#032F62;"> /var/log/nginx/%Y/%m/%d/access.log</span><span style="color:#24292E;"> &amp;</span></span></code></pre></div></li><li><p>使用<code>rotatelogs</code>：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6F42C1;">cat</span><span style="color:#032F62;"> /var/log/nginx/access.log.pipe</span><span style="color:#D73A49;"> |</span><span style="color:#6F42C1;"> rotatelogs</span><span style="color:#032F62;"> /var/log/nginx/access.log.%Y-%m-%d</span><span style="color:#005CC5;"> 86400</span><span style="color:#24292E;"> &amp;</span></span></code></pre></div></li></ul></li></ol><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li>确保在切割日志后，Nginx能够正确写入新的日志文件。</li><li>使用<code>kill -USR1</code>信号通知Nginx重新打开日志文件。</li><li>定期检查日志文件的大小和切割策略，以确保系统性能。</li></ul><h2 id="拓展阅读" tabindex="-1">拓展阅读 <a class="header-anchor" href="#拓展阅读" aria-label="Permalink to &quot;拓展阅读&quot;">​</a></h2><ul><li><a href="http://tengine.taobao.org/" target="_blank" rel="noreferrer">tengine</a></li><li><a href="http://tengine.taobao.org/documentation_cn.html" target="_blank" rel="noreferrer">tengine中文文档</a></li></ul>`,58)]))}const u=l(e,[["render",o]]);export{h as __pageData,u as default};
