import{_ as e,c as a,o as i,ag as t}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"1.5 DOM优化","description":"","frontmatter":{},"headers":[],"relativePath":"performanceGeek/1.5DOM优化.md","filePath":"performanceGeek/1.5DOM优化.md"}'),r={name:"performanceGeek/1.5DOM优化.md"};function o(p,l,n,s,d,c){return i(),a("div",null,l[0]||(l[0]=[t('<h1 id="_1-5-dom优化" tabindex="-1">1.5 DOM优化 <a class="header-anchor" href="#_1-5-dom优化" aria-label="Permalink to &quot;1.5 DOM优化&quot;">​</a></h1><h2 id="减少回流和重绘" tabindex="-1">减少回流和重绘 <a class="header-anchor" href="#减少回流和重绘" aria-label="Permalink to &quot;减少回流和重绘&quot;">​</a></h2><h3 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h3><ul><li><p>避免过多样式嵌套</p></li><li><p>避免使用 CSS 表达式</p></li><li><p>使用绝对定位，可以让动画元素脱离文档流</p></li><li><p>避免使用 table 布局</p></li><li><p>尽量不使用 float 布局</p></li><li><p>图片最好设置好width 和height</p></li><li><p>尽量简化浏览器不必要的任务，减少页面重新布局</p></li><li><p>使用 Viewport 设置屏幕缩放级别</p></li><li><p>避免频繁设置样式，最好把新style属性设置完成后，进行一次性更改 避免使用引起回流/重绘的属性，最好把相应变量缓存起来</p></li></ul><h3 id="js" tabindex="-1">JS <a class="header-anchor" href="#js" aria-label="Permalink to &quot;JS&quot;">​</a></h3><ul><li>最小化回流和重排 <ul><li>为了减少回流发生次数，避免频繁或操作DOM，可以合并多次对DOM 修改，然后一次性批量处理。</li></ul></li><li>控制绘制过程和绘制区域 <ul><li>绘制过程开销比较大的属性设置应该尽量避免减少使用</li><li>减少绘制区域范围</li></ul></li></ul><h2 id="dom优化" tabindex="-1">DOM优化 <a class="header-anchor" href="#dom优化" aria-label="Permalink to &quot;DOM优化&quot;">​</a></h2><ul><li><p>众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量DOM 元素。想象一下，从一个上万节点的DOM 树上，使用querySelectorAll或getElementByTagName方法查找某一个节点，是非常耗时的。另外元素绑定事件，事件冒泡和事件捕获的执行也会相对耗时。</p></li><li><p>通常控制DOM 大小的技巧包括:</p><ul><li>合理的业务逻辑</li><li>延迟加载即将呈现的内容</li></ul></li><li><p>对 DOM 节点的操作统一处理后，再统一插入到 DOM Tree中。</p></li><li><p>可以使用fragment，尽量不在页面 DOM1 Tree 里直接操作。</p></li><li><p>现在流行的框架Angular、React、Vue都在使用虚拟 DOM 技术，通过 diff 算法简化和减少 DOM 操作。</p></li></ul>',8)]))}const _=e(r,[["render",o]]);export{u as __pageData,_ as default};
