import{_ as i,c as a,o as e,ag as r}from"./chunks/framework.DPDPlp3K.js";const p=JSON.parse('{"title":"数据结构与算法","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/README.md","filePath":"algorithm/README.md"}'),t={name:"algorithm/README.md"};function h(o,l,n,u,d,s){return e(),a("div",null,l[0]||(l[0]=[r('<h1 id="数据结构与算法" tabindex="-1">数据结构与算法 <a class="header-anchor" href="#数据结构与算法" aria-label="Permalink to &quot;数据结构与算法&quot;">​</a></h1><p>数据结构：一组数据的存储结构</p><p>算法：操作数据的一组方法</p><p>解决问题：数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。</p><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h2><p>逻辑结构、存储结构</p><h3 id="逻辑结构" tabindex="-1">逻辑结构 <a class="header-anchor" href="#逻辑结构" aria-label="Permalink to &quot;逻辑结构&quot;">​</a></h3><ul><li>线性表结构：数组、栈、队列、链表。</li><li>非线性结构：二维数组、堆、树、图。 <ul><li>树分类： <ul><li>完全二叉树</li><li>满二叉树</li><li>二叉搜索树</li><li>平衡二叉树</li><li>红黑树</li><li>AVL树</li><li>哈夫曼树</li><li>字典树</li><li>B+树</li></ul></li></ul></li></ul><h3 id="存储结构" tabindex="-1">存储结构 <a class="header-anchor" href="#存储结构" aria-label="Permalink to &quot;存储结构&quot;">​</a></h3><ul><li>顺序存储</li><li>链式存储</li><li>索引存储</li><li>散列存储</li></ul><h2 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h2><h3 id="算法思想" tabindex="-1">算法思想 <a class="header-anchor" href="#算法思想" aria-label="Permalink to &quot;算法思想&quot;">​</a></h3><ul><li>分治法</li><li>贪婪法</li><li>回溯法/试探法</li><li>动态规划</li><li>枚举法</li><li>模拟法</li></ul><h3 id="算法技巧" tabindex="-1">算法技巧 <a class="header-anchor" href="#算法技巧" aria-label="Permalink to &quot;算法技巧&quot;">​</a></h3><ul><li>双指针 <ul><li>左右端点指针</li><li>快慢指针</li><li>固定间距指针</li></ul></li><li>递推法 <ul><li>顺推法</li><li>逆推法</li></ul></li><li>递归法</li><li>枚举法</li></ul><h3 id="排序算法" tabindex="-1">排序算法 <a class="header-anchor" href="#排序算法" aria-label="Permalink to &quot;排序算法&quot;">​</a></h3><ul><li><p>冒泡排序</p></li><li><p>快速排序</p></li><li><p>选择排序</p></li><li><p>插入排序</p></li><li><p>希尔排序</p></li><li><p>归并排序</p></li><li><p>计数排序</p></li><li><p>基数排序</p></li><li><p>堆排序</p></li><li><p>桶排序</p></li><li><p>猴子排序</p></li><li><p>面条排序</p></li><li><p>睡眠排序</p></li></ul><h4 id="排序算法分类" tabindex="-1">排序算法分类 <a class="header-anchor" href="#排序算法分类" aria-label="Permalink to &quot;排序算法分类&quot;">​</a></h4><h5 id="基于比较排序" tabindex="-1">基于比较排序 <a class="header-anchor" href="#基于比较排序" aria-label="Permalink to &quot;基于比较排序&quot;">​</a></h5><p>通过比较元素之间的大小关系来实现排序，常见包括：冒泡排序、快速排序、归并排序、插入排序、堆排序</p><p>比较排序的理论限制：</p><ul><li>基于比较的排序算法的时间复杂度下限是 O(nlogn)</li><li>这是通过决策树模型证明的理论下限</li><li>任何基于比较的排序算法，都无法突破这个限制</li></ul><h5 id="线性排序" tabindex="-1">线性排序 <a class="header-anchor" href="#线性排序" aria-label="Permalink to &quot;线性排序&quot;">​</a></h5><h5 id="基本排序" tabindex="-1">基本排序 <a class="header-anchor" href="#基本排序" aria-label="Permalink to &quot;基本排序&quot;">​</a></h5><ul><li>冒泡排序</li><li>快速排序</li><li>选择排序</li><li>归并排序</li><li>插入排序</li><li>希尔排序</li></ul><h5 id="高级排序" tabindex="-1">高级排序 <a class="header-anchor" href="#高级排序" aria-label="Permalink to &quot;高级排序&quot;">​</a></h5><ul><li>计数排序</li><li>基数排序</li><li>堆排序</li><li>桶排序</li></ul><h5 id="内部排序" tabindex="-1">内部排序 <a class="header-anchor" href="#内部排序" aria-label="Permalink to &quot;内部排序&quot;">​</a></h5><p>内排序是指所有的数据已经读入内存，在内存中进行排序的算法。排序过程中不需要对磁盘进行读写。同时，内排序也一般假定所有用到的辅助空间也可以直接存在于内存中。</p><ul><li>冒泡排序</li><li>快速排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序</li><li>堆排序</li></ul><p>其中冒泡排序和快速排序属于交换排序，插入排序和希尔排序属于插入排序</p><h5 id="外部排序" tabindex="-1">外部排序 <a class="header-anchor" href="#外部排序" aria-label="Permalink to &quot;外部排序&quot;">​</a></h5><p>外排序，即内存中无法保存全部数据，需要进行磁盘访问，每次读入部分数据到内存进行排序。</p><ul><li>计数排序</li><li>基数排序</li><li>桶排序等</li></ul><h3 id="分析排序算法" tabindex="-1">分析排序算法 <a class="header-anchor" href="#分析排序算法" aria-label="Permalink to &quot;分析排序算法&quot;">​</a></h3><h4 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h4><p>执行效率是算法一个非常重要的考量指标。评估算法的执行效率： 时间复杂度、空间复杂度</p><h5 id="排序算法的执行效率" tabindex="-1">排序算法的执行效率 <a class="header-anchor" href="#排序算法的执行效率" aria-label="Permalink to &quot;排序算法的执行效率&quot;">​</a></h5><ol><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数 、低阶</li><li>比较次数和交换（或移动）次数</li></ol><h5 id="排序算法的内存消耗" tabindex="-1">排序算法的内存消耗 <a class="header-anchor" href="#排序算法的内存消耗" aria-label="Permalink to &quot;排序算法的内存消耗&quot;">​</a></h5><h5 id="排序算法的稳定性" tabindex="-1">排序算法的稳定性 <a class="header-anchor" href="#排序算法的稳定性" aria-label="Permalink to &quot;排序算法的稳定性&quot;">​</a></h5><h3 id="搜索算法" tabindex="-1">搜索算法 <a class="header-anchor" href="#搜索算法" aria-label="Permalink to &quot;搜索算法&quot;">​</a></h3><ul><li>顺序查找</li><li>二分查找/折半查找</li><li>二叉搜索树</li><li>索引查找</li><li>散列表</li></ul><h4 id="搜索策略" tabindex="-1">搜索策略 <a class="header-anchor" href="#搜索策略" aria-label="Permalink to &quot;搜索策略&quot;">​</a></h4><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><h2 id="拓展" tabindex="-1">拓展 <a class="header-anchor" href="#拓展" aria-label="Permalink to &quot;拓展&quot;">​</a></h2><p>其它算法：</p><ul><li>DOM-Diff</li><li>摇树算法</li><li>结构化克隆算法</li><li>Nagle算法</li></ul>',48)]))}const b=i(t,[["render",h]]);export{p as __pageData,b as default};
