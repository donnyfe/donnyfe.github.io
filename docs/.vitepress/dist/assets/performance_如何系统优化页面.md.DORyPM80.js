import{_ as s,c as n,o as l,ag as o}from"./chunks/framework.DPDPlp3K.js";const e="/assets/%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.C94ZfTbh.png",u=JSON.parse('{"title":"如何系统优化页面","description":"","frontmatter":{},"headers":[],"relativePath":"performance/如何系统优化页面.md","filePath":"performance/如何系统优化页面.md"}'),p={name:"performance/如何系统优化页面.md"};function t(r,a,c,i,d,y){return l(),n("div",null,a[0]||(a[0]=[o('<h1 id="如何系统优化页面" tabindex="-1">如何系统优化页面 <a class="header-anchor" href="#如何系统优化页面" aria-label="Permalink to &quot;如何系统优化页面&quot;">​</a></h1><h2 id="页面生存周期" tabindex="-1">页面生存周期 <a class="header-anchor" href="#页面生存周期" aria-label="Permalink to &quot;页面生存周期&quot;">​</a></h2><p>一般所谈论的页面优化，其实就是要让页面更快地显示和响应，这需要分析一个页面生存周期的不同阶段，通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。</p><ul><li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li><li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li><li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。</li></ul><p>其中需要重点关注加载阶段和交互阶段。</p><h2 id="加载阶段" tabindex="-1">加载阶段 <a class="header-anchor" href="#加载阶段" aria-label="Permalink to &quot;加载阶段&quot;">​</a></h2><p><img src="'+e+`" alt="加载阶段渲染流水线"></p><h3 id="关键资源" tabindex="-1">关键资源 <a class="header-anchor" href="#关键资源" aria-label="Permalink to &quot;关键资源&quot;">​</a></h3><p>并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。我们把<strong>能够阻塞网页首次渲染的资源称为关键资源</strong>。</p><h3 id="影响页面首次渲染的核心因素" tabindex="-1">影响页面首次渲染的核心因素 <a class="header-anchor" href="#影响页面首次渲染的核心因素" aria-label="Permalink to &quot;影响页面首次渲染的核心因素&quot;">​</a></h3><p><strong>第一个是关键资源个数。</strong> 关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</p><p><strong>第二个是关键资源大小。</strong> 通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</p><p><strong>第三个是请求关键资源需要多少个 RTT（Round Trip Time）。</strong> 当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。**RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。**通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</p><p>结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，通常可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个。这里最大的是 CSS 文件（9KB），由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。</p><h2 id="加载阶段优化方案" tabindex="-1">加载阶段优化方案 <a class="header-anchor" href="#加载阶段优化方案" aria-label="Permalink to &quot;加载阶段优化方案&quot;">​</a></h2><h3 id="总的优化原则" tabindex="-1">总的优化原则 <a class="header-anchor" href="#总的优化原则" aria-label="Permalink to &quot;总的优化原则&quot;">​</a></h3><ul><li>减少关键资源个数</li><li>降低关键资源大小</li><li>降低关键资源的 RTT 次数。</li></ul><h3 id="_1-减少关键资源的个数" tabindex="-1">1.减少关键资源的个数 <a class="header-anchor" href="#_1-减少关键资源的个数" aria-label="Permalink to &quot;1.减少关键资源的个数&quot;">​</a></h3><ul><li>可以将 JavaScript 和 CSS 改成内联的形式。</li><li>如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性，改变成非关键资源。</li><li>对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志，改变成非关键资源。</li></ul><h3 id="_2-减少关键资源的大小" tabindex="-1">2.减少关键资源的大小 <a class="header-anchor" href="#_2-减少关键资源的大小" aria-label="Permalink to &quot;2.减少关键资源的大小&quot;">​</a></h3><ul><li>压缩 CSS 和 JavaScript 资源。</li><li>移除 HTML、CSS、JavaScript 文件中一些注释内容。</li><li>取消 CSS 或者 JavaScript 中关键资源的方式。</li></ul><h3 id="_3-减少关键资源-rtt-的次数" tabindex="-1">3.减少关键资源 RTT 的次数 <a class="header-anchor" href="#_3-减少关键资源-rtt-的次数" aria-label="Permalink to &quot;3.减少关键资源 RTT 的次数&quot;">​</a></h3><ul><li>可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。</li><li>除此之外，还可以使用 CDN 来减少每次 RTT 时长。</li></ul><p>在优化实际的页面加载速度时，可以先画出优化之前关键资源的图表，然后按照上面优化关键资源的原则去优化，优化完成之后再画出优化之后的关键资源图表。</p><h2 id="交互阶段" tabindex="-1">交互阶段 <a class="header-anchor" href="#交互阶段" aria-label="Permalink to &quot;交互阶段&quot;">​</a></h2><p>谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。</p><p>交互阶段是如何生成一个帧的？大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。</p><p>如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</p><p>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。</p><p>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p><h2 id="交互阶段优化方案" tabindex="-1">交互阶段优化方案 <a class="header-anchor" href="#交互阶段优化方案" aria-label="Permalink to &quot;交互阶段优化方案&quot;">​</a></h2><p>一个大的原则就是让单个帧的生成速度变快。</p><p>内容包括：</p><ol><li>减少 JavaScript 脚本执行时间</li><li>避免强制同步布局</li><li>避免布局抖动</li><li>合理利用 CSS 合成动画</li><li>避免频繁的垃圾回收</li></ol><h3 id="_1-减少-javascript-脚本执行时间" tabindex="-1">1. 减少 JavaScript 脚本执行时间 <a class="header-anchor" href="#_1-减少-javascript-脚本执行时间" aria-label="Permalink to &quot;1. 减少 JavaScript 脚本执行时间&quot;">​</a></h3><p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：</p><ul><li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li><li>另一种是采用 Web Workers。可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。</li></ul><p>总之，在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程。</p><h3 id="_2-避免强制同步布局" tabindex="-1">2. 避免强制同步布局 <a class="header-anchor" href="#_2-避免强制同步布局" aria-label="Permalink to &quot;2. 避免强制同步布局&quot;">​</a></h3><p>正常情况下的布局操作。通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。</p><p>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> foo</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> main_div </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;mian_div&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> new_node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;li&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> textnode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createTextNode</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;time.geekbang&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  new_node.</span><span style="color:#6F42C1;">appendChild</span><span style="color:#24292E;">(textnode);</span></span>
<span class="line"><span style="color:#24292E;">  document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;mian_div&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">appendChild</span><span style="color:#24292E;">(new_node);</span></span>
<span class="line"><span style="color:#6A737D;">  // 由于要获取到 offsetHeight，</span></span>
<span class="line"><span style="color:#6A737D;">  // 但是此时的 offsetHeight 还是老的数据，</span></span>
<span class="line"><span style="color:#6A737D;">  // 所以需要立即执行布局操作</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(main_div.offsetHeight)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。</p><h3 id="_3-避免布局抖动" tabindex="-1">3. 避免布局抖动 <a class="header-anchor" href="#_3-避免布局抖动" aria-label="Permalink to &quot;3. 避免布局抖动&quot;">​</a></h3><p>所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> foo</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">    let</span><span style="color:#24292E;"> time_li </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;time_li&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">    for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#005CC5;"> 100</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">        let</span><span style="color:#24292E;"> main_div </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;mian_div&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">        let</span><span style="color:#24292E;"> new_node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;li&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">        let</span><span style="color:#24292E;"> textnode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createTextNode</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;time.geekbang&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        new_node.</span><span style="color:#6F42C1;">appendChild</span><span style="color:#24292E;">(textnode);</span></span>
<span class="line"><span style="color:#24292E;">        new_node.offsetHeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> time_li.offsetHeight;</span></span>
<span class="line"><span style="color:#24292E;">        document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;mian_div&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">appendChild</span><span style="color:#24292E;">(new_node);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。</p><p>在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</p><h3 id="_4-合理利用css合成动画" tabindex="-1">4. 合理利用CSS合成动画 <a class="header-anchor" href="#_4-合理利用css合成动画" aria-label="Permalink to &quot;4. 合理利用CSS合成动画&quot;">​</a></h3><p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS动画依然能继续执行。所以要尽量利用好CSS合成动画，如果能让CSS处理动画，就尽量交给CSS来操作。</p><p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p><h3 id="_5-避免频繁的垃圾回收" tabindex="-1">5. 避免频繁的垃圾回收 <a class="header-anchor" href="#_5-避免频繁的垃圾回收" aria-label="Permalink to &quot;5. 避免频繁的垃圾回收&quot;">​</a></h3><p>JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p><p>所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p>`,54)]))}const S=s(p,[["render",t]]);export{u as __pageData,S as default};
