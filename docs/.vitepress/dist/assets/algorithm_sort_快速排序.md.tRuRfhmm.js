import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.DPDPlp3K.js";const C=JSON.parse('{"title":"快速排序 Quick Sort","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/sort/快速排序.md","filePath":"algorithm/sort/快速排序.md"}'),o={name:"algorithm/sort/快速排序.md"};function e(t,s,r,c,y,i){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="快速排序-quick-sort" tabindex="-1">快速排序 Quick Sort <a class="header-anchor" href="#快速排序-quick-sort" aria-label="Permalink to &quot;快速排序 Quick Sort&quot;">​</a></h1><p>快速排序是对冒泡排序的改进。1962年由东尼·霍尔，Charles Antony Richard Hoare提出。著作《算法导论》。</p><ul><li>算法策略: 分治法</li><li>时间复杂度: 平均: O(nlogn)、最好: O(nlogn)、最坏: O(n2)</li><li>空间复杂度: O(logn)</li><li>稳定性: 不稳定(排序后2个相等键值的顺序和排序之前它们的顺序不相同)</li><li>排序方式: in-place(占用常数内存，不占用额外内存)</li><li>特点： <ul><li>选择基准值（pivot）</li><li>将数组分为两部分，小于基准值的放左边，大于基准值的放右边</li><li>递归处理左右两部分</li></ul></li></ul><blockquote><p>注: 快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(n log n) ，且O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。——《算法艺术与信息学竞赛》</p></blockquote><h2 id="排序原理" tabindex="-1">排序原理 <a class="header-anchor" href="#排序原理" aria-label="Permalink to &quot;排序原理&quot;">​</a></h2><ol><li>取中间基准值，首次排序进行分区操作，将数据和基准值进行比较分成两部分，一部分比另一部分的所有数据都要小。</li><li>然后递归调用，在两边都实行快速排序。</li></ol><blockquote><p>注: 快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。 ——《算法 第四版》</p></blockquote><h2 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h2><h3 id="版本一" tabindex="-1">版本一 <a class="header-anchor" href="#版本一" aria-label="Permalink to &quot;版本一&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#6F42C1;"> quickSort</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 递归终止退出条件</span></span>
<span class="line"><span style="color:#D73A49;">    if</span><span style="color:#24292E;">(arr.</span><span style="color:#005CC5;">length</span><span style="color:#D73A49;"> &lt;=</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> arr;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">    let</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [], right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 二分法-获取数组中间元素</span></span>
<span class="line"><span style="color:#D73A49;">    let</span><span style="color:#24292E;"> midIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">floor</span><span style="color:#24292E;">(arr.</span><span style="color:#005CC5;">length</span><span style="color:#D73A49;"> /</span><span style="color:#005CC5;"> 2</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">        midValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr.</span><span style="color:#6F42C1;">splice</span><span style="color:#24292E;">(midIndex, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">    for</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> arr.</span><span style="color:#005CC5;">length</span><span style="color:#D73A49;"> -</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 以中间元素作边界，划分两个集合</span></span>
<span class="line"><span style="color:#D73A49;">        if</span><span style="color:#24292E;">(arr[i] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> midValue) {</span></span>
<span class="line"><span style="color:#24292E;">            left.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(arr[i])</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            right.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(arr[i])</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 继续递归子集合，然后合并</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#6F42C1;"> quickSort</span><span style="color:#24292E;">(left).</span><span style="color:#6F42C1;">concat</span><span style="color:#24292E;">([midValue], </span><span style="color:#6F42C1;">quickSort</span><span style="color:#24292E;">(right));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> arr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">6</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">7</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">7</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">quickSort</span><span style="color:#24292E;">(arr));</span></span></code></pre></div><h3 id="版本二" tabindex="-1">版本二 <a class="header-anchor" href="#版本二" aria-label="Permalink to &quot;版本二&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> quickSort</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">, </span><span style="color:#E36209;">left</span><span style="color:#24292E;">, </span><span style="color:#E36209;">right</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">    let</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">,  partitionIndex,</span></span>
<span class="line"><span style="color:#24292E;">        left </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> typeof</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">!=</span><span style="color:#032F62;"> &#39;number&#39;</span><span style="color:#D73A49;"> ?</span><span style="color:#005CC5;"> 0</span><span style="color:#D73A49;"> :</span><span style="color:#24292E;"> left,</span></span>
<span class="line"><span style="color:#24292E;">        right </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> typeof</span><span style="color:#24292E;"> right </span><span style="color:#D73A49;">!=</span><span style="color:#032F62;"> &#39;number&#39;</span><span style="color:#D73A49;"> ?</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;"> 1</span><span style="color:#D73A49;"> :</span><span style="color:#24292E;"> right;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">    if</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> right) {</span></span>
<span class="line"><span style="color:#24292E;">        partitionIndex </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> partition</span><span style="color:#24292E;">(arr, left, right);</span></span>
<span class="line"><span style="color:#6F42C1;">        quickSort</span><span style="color:#24292E;">(arr, left, partitionIndex</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">        quickSort</span><span style="color:#24292E;">(arr, partitionIndex</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, right);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> arr;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//分区操作</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> partition</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">, </span><span style="color:#E36209;">left</span><span style="color:#24292E;"> ,</span><span style="color:#E36209;">right</span><span style="color:#24292E;">) {  </span></span>
<span class="line"><span style="color:#D73A49;">    let</span><span style="color:#24292E;"> pivot </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> left,                   </span><span style="color:#6A737D;">//设定基准（pivot）</span></span>
<span class="line"><span style="color:#24292E;">        index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pivot </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">    for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> index; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> right; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">        if</span><span style="color:#24292E;"> (arr[i] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> arr[pivot]) {</span></span>
<span class="line"><span style="color:#6F42C1;">            swap</span><span style="color:#24292E;">(arr, i, index);</span></span>
<span class="line"><span style="color:#24292E;">            index</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#6F42C1;">    swap</span><span style="color:#24292E;">(arr, pivot, index </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> index</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> swap</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">, </span><span style="color:#E36209;">i</span><span style="color:#24292E;">, </span><span style="color:#E36209;">j</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">    var</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr[i];</span></span>
<span class="line"><span style="color:#24292E;">    arr[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr[j];</span></span>
<span class="line"><span style="color:#24292E;">    arr[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> temp;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div>`,12)]))}const A=n(o,[["render",e]]);export{C as __pageData,A as default};
