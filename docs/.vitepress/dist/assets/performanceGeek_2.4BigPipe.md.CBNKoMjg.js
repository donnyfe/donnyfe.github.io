import{_ as i,c as a,o as t,ag as r}from"./chunks/framework.DPDPlp3K.js";const g=JSON.parse('{"title":"2.4 BigPipe","description":"","frontmatter":{},"headers":[],"relativePath":"performanceGeek/2.4BigPipe.md","filePath":"performanceGeek/2.4BigPipe.md"}'),l={name:"performanceGeek/2.4BigPipe.md"};function o(p,e,c,n,d,s){return t(),a("div",null,e[0]||(e[0]=[r('<h1 id="_2-4-bigpipe" tabindex="-1">2.4 BigPipe <a class="header-anchor" href="#_2-4-bigpipe" aria-label="Permalink to &quot;2.4 BigPipe&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>BigPipe 通过将页面加载到称为page let 的小部件中，来加快页面渲染速度，并允许浏览器在 php 服务器呈现页面的同时，一直直请求页面不同区块的结构，类似一个“流”传输管道。</p><h2 id="技术实现" tabindex="-1">技术实现 <a class="header-anchor" href="#技术实现" aria-label="Permalink to &quot;技术实现&quot;">​</a></h2><ol><li>浏览器从服务器请求页面</li><li>Server 迅速呈现一个包含<code>&lt;head&gt;</code>标记的页面框架，以及一个包含空div元素的主体，这些元素充当 pagelet的容器。由于该页面尚未完成，因此与浏览器的HTTP 连接保持打开状态。</li><li>浏览器将开始下载bigpipe.js文件，然后它将开始呈现页面。</li><li>PHP 服务器进程仍在执行，并且一次构建每个Pagelet。Pagelet完成后，其结果将在<code>&lt;script&gt; BigPipe.onArrive (...)&lt;/ script&gt;</code>标记内发送到浏览器。</li><li>浏览器将收到的html代码注入正确的位置。如果小页面需要任何CSS资源，则也将下载这些 CSS 资源。</li><li>接收完所有的页面集之后，浏览器将开始加载月那些页面集所需的所有外部JavaScript文件。</li><li>下载javaScript后，浏览器将执行所有内联Ja vaScript。</li></ol>',5)]))}const P=i(l,[["render",o]]);export{g as __pageData,P as default};
