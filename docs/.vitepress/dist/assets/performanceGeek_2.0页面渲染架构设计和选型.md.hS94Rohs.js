import{_ as a,c as l,o as i,ag as r}from"./chunks/framework.DPDPlp3K.js";const t="/assets/image-20201020232014287.D0RGU0N5.png",_=JSON.parse('{"title":"2.0 页面渲染架构设计&选型","description":"","frontmatter":{},"headers":[],"relativePath":"performanceGeek/2.0页面渲染架构设计和选型.md","filePath":"performanceGeek/2.0页面渲染架构设计和选型.md"}'),o={name:"performanceGeek/2.0页面渲染架构设计和选型.md"};function n(h,e,s,p,d,u){return i(),l("div",null,e[0]||(e[0]=[r('<h1 id="_2-0-页面渲染架构设计-选型" tabindex="-1">2.0 页面渲染架构设计&amp;选型 <a class="header-anchor" href="#_2-0-页面渲染架构设计-选型" aria-label="Permalink to &quot;2.0 页面渲染架构设计&amp;选型&quot;">​</a></h1><h2 id="页面渲染过程" tabindex="-1">页面渲染过程 <a class="header-anchor" href="#页面渲染过程" aria-label="Permalink to &quot;页面渲染过程&quot;">​</a></h2><p><img src="'+t+'" alt="image-20201020232014287"></p><ol><li><p>浏览器解析 HTML，生成 DOM Tree(Parse HTML)</p></li><li><p>浏览器解析 CSS，生成CSSOM (CSS Object Mode el) Tree。</p></li><li><p>JavaScript会通过 DOM API和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree，浏览器将DOM Tree和CSSOM Tree合成渲染树(Render Tree)。</p></li><li><p>布局(Layout): 根据生成的Render Tree，进行回流，以计算每个节点的几何信息(位置、大小、字体样式等等)。</p></li><li><p>绘制(Painting): 根据渲染树和回流得到的几何信言息，得到每个节点的绝对像素。</p></li><li><p>展示(Display): 将像素发送给图形处理器(GPU)，展示在页面上。</p></li></ol><h2 id="页面渲染技术架构和方案" tabindex="-1">页面渲染技术架构和方案 <a class="header-anchor" href="#页面渲染技术架构和方案" aria-label="Permalink to &quot;页面渲染技术架构和方案&quot;">​</a></h2><ol><li>服务端渲染</li></ol><ul><li>后端同步渲染、同构直出、BigPipe</li></ul><ol><li>客户端渲染</li></ol><ul><li>JavaScript 渲染:静态化、前后端分离、单页面应用</li><li>Web App: Angular、React、Vue等，PWA</li><li>原生 App:iOS、Android</li><li>Hybrid App: PhoneGap、AppCan 等</li><li>跨平台开发:RN、Flutter、小程序等</li></ul><h2 id="后端同步渲染" tabindex="-1">后端同步渲染 <a class="header-anchor" href="#后端同步渲染" aria-label="Permalink to &quot;后端同步渲染&quot;">​</a></h2><h3 id="同步渲染步骤-以jsp-为例" tabindex="-1">同步渲染步骤(以JSP 为例) <a class="header-anchor" href="#同步渲染步骤-以jsp-为例" aria-label="Permalink to &quot;同步渲染步骤(以JSP 为例)&quot;">​</a></h3><ul><li>步骤1:JSP Servlet 映射以.jsp 结尾的 URL，当.jsp文件请求时，servlet容器知道要调用哪个 Servlet。</li><li>步骤2:Servlet 容器检查Servlet是否已被编译。</li><li>步骤3:如果未在步骤2中进行编译，则Servlet容器会将JSP转换为Servlet代码，并进行编译。</li><li>步骤4:Servlet 容器将JSP请求转发到编译JSP Servlet 类。</li><li>步骤5:JSP Servlet类返回并发送给客户端浏览器HTML。</li></ul><h3 id="技术优点" tabindex="-1">技术优点 <a class="header-anchor" href="#技术优点" aria-label="Permalink to &quot;技术优点&quot;">​</a></h3><ul><li>快速实现业务开发并上线</li></ul><h3 id="技术不足" tabindex="-1">技术不足 <a class="header-anchor" href="#技术不足" aria-label="Permalink to &quot;技术不足&quot;">​</a></h3><ul><li>需要先实现业务逻辑和功能，再输出HTML内容给浏览器，用户需等待HTML页面完全加载之后才能看到页面内容;代码耦合严重，不太好业务逻辑和页面模板;需求变更上线周期相对较长。</li></ul><h3 id="协作方式" tabindex="-1">协作方式 <a class="header-anchor" href="#协作方式" aria-label="Permalink to &quot;协作方式&quot;">​</a></h3><ul><li>前端出静态页面，后端套页面</li></ul><h3 id="选型建议" tabindex="-1">选型建议 <a class="header-anchor" href="#选型建议" aria-label="Permalink to &quot;选型建议&quot;">​</a></h3><ul><li>如果是创业初期验证阶段，或者20个研发人员以内的项目，为了满足业务快速验证并一天内多次上线，技术选型上使用服务端同步渲染没有任何问题，一人字就是“快”。</li></ul><h3 id="协作力器" tabindex="-1">协作力器 <a class="header-anchor" href="#协作力器" aria-label="Permalink to &quot;协作力器&quot;">​</a></h3><ul><li>jSmart</li><li>Velocity.js</li></ul>',22)]))}const S=a(o,[["render",n]]);export{_ as __pageData,S as default};
